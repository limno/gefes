Sample "{{sample_short_name}}"
==============================

General Information
-------------------
This sample has the code "{{sample_short_name}}" and is named "{{sample_long_name}}". It is part of the project code "{{project_short_name}}" called "{{project_long_name}}" along with {{project_other_samples}} other samples.

-------

Meta-data details
-----------------
The JSON file located online at:

> <{{json_url}}>

contains all the metadata associated with this sample. Here are the contents of this file:

    {{json_content}}

-------

Processing
----------
This report (and all the analysis) was generated using the GEFES project at:

> <{{project_url}}>

Version `{{project_version}}` of the pipeline was used. The exact git hash of the latest commit was:

    {{git_hash}}

also more simply referred to by its shortened tag `{{git_tag}}`.

This document was generated at `{{now}}`.

A brief overview of what happens to the data can be viewed online here:

> <https://github.com/limno/gefes/blob/{{git_branch}}/documentation/flowchart.pdf?raw=true>

The results and all the files generated for this sample can be found on UPPMAX at:

    {{results_directory}}

-------

Raw data
--------
* The forward read file weighed *{{fwd_size}}* and contained *{{fwd_count}}* reads.
* The reverse read file weighed *{{rev_size}}* and contained *{{rev_count}}* reads.

More information about the raw output of the sequencer for this sample can be found in the HTML report generated by the Illumina software here:

    {{illumina_report}}

The average quality per base can be seen in figure \ref{raw_per_base_qual} and the average quality per sequence in figure \ref{raw_per_seq_qual}.

{{raw_per_base_qual}}

{{raw_per_seq_qual}}

-------

Preprocessing
-------------
Next, we filter the sequences based on the following rules:

* We remove any bases from the extremities of each sequence if they are under the quality threshold of {{phred_threshold}}.

* We run a {{window_size}} base pair window over the sequences and check that the quality doesn't drop below the same threshold of {{phred_threshold}}. If it does, we trim the read and keep the longest stretch.

* If the resulting trimmed read is shorter than {{length_threshold}} base pairs or contains any undetermined "N" bases, we keep discard it.

* In the event that one of the reads in a pair gets discarded while the other one does not, we place the resulting singleton in a separate "singles" FASTQ file.

This leaves us with {{remaining_percent}} of the original sequences organized in {{remaining_pairs}} pairs and {{remaining_singles}} singletons.

Of course, now, not all sequences have the same length and we have created a distribution of read sizes as seen in figure \ref{cleaned_len_dist}.

{{cleaned_len_dist}}

The singletons have their own length distribution shown in figure \ref{singletons_len_dist}:

{{singletons_len_dist}}

We can look again at the per base quality and the per sequence quality of the pairs in figure \ref{cleaned_per_base_qual} and \ref{cleaned_per_seq_qual}:

{{cleaned_per_base_qual}}

{{cleaned_per_seq_qual}}

The next step in the pipeline is to combine several samples together in an "aggregate" object and co-assemble them. The result of this operation is available in the report of the corresponding aggregate.